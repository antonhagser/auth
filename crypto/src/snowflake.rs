//! This module provides the `Snowflake` struct and `SnowflakeGenerator` for generating
//! unique and sortable IDs based on a timestamp, worker ID, and sequence number.
//!
//! The `Snowflake` struct consists of a 64-bit integer where the first 42 bits represent
//! the timestamp, the next 5 bits represent the worker ID, and the last 12 bits represent
//! a sequence number.
//!
//! The `SnowflakeGenerator` is a thread-safe structure that can be used to generate
//! snowflakes using the current time, a worker ID, and an atomic sequence number.

use std::cmp::Ordering;
use std::num::ParseIntError;
use std::str::FromStr;
use std::sync::atomic::{AtomicI64, AtomicU16, Ordering as AtomicOrdering};
use std::thread;
use std::time::Duration;

use chrono::{DateTime, NaiveDateTime, Utc};

/// Customize the start time as desired
const UNIX_START_TIME: i64 = 1_589_870_119_000;

/// The Snowflake struct represents a unique and sortable ID.
#[derive(Debug, Eq)]
pub struct Snowflake {
    timestamp: i64,
    worker_id: u8,
    sequence: u16,
}

impl Snowflake {
    /// Returns the UTC time represented by the Snowflake's timestamp.
    pub fn get_time(&self) -> DateTime<Utc> {
        let naive_time =
            NaiveDateTime::from_timestamp_opt((self.timestamp + UNIX_START_TIME) / 1000, 0)
                .expect("failed to convert timestamp to NaiveDateTime");
        DateTime::<Utc>::from_utc(naive_time, Utc)
    }

    /// Returns the 64-bit integer ID of the Snowflake.
    pub fn get_id(&self) -> u64 {
        ((self.timestamp - UNIX_START_TIME) << 22) as u64
            | (self.worker_id as u64) << 17
            | self.sequence as u64
    }

    /// Creates a Snowflake from a 64-bit integer ID.
    ///
    /// # Arguments
    ///
    /// * `id` - A 64-bit integer representing the Snowflake ID.
    pub fn from_id(id: u64) -> Snowflake {
        let timestamp = (id >> 22) as i64 + UNIX_START_TIME;
        let worker_id = ((id >> 17) & 0x1F) as u8;
        let sequence = (id & 0xFFF) as u16;

        Snowflake {
            timestamp,
            worker_id,
            sequence,
        }
    }

    /// Returns the timestamp of the Snowflake.
    pub fn timestamp(&self) -> i64 {
        self.timestamp
    }

    /// Returns the worker ID of the Snowflake.
    pub fn worker_id(&self) -> u8 {
        self.worker_id
    }

    /// Returns the sequence of the Snowflake.
    pub fn sequence(&self) -> u16 {
        self.sequence
    }
}

impl FromStr for Snowflake {
    type Err = ParseIntError;

    /// Creates a Snowflake from a string representation of the 64-bit integer ID.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let snowflake = u64::from_str(s)?;
        Ok(Snowflake::from_id(snowflake))
    }
}

impl PartialOrd for Snowflake {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.timestamp.partial_cmp(&other.timestamp)
    }
}

impl Ord for Snowflake {
    fn cmp(&self, other: &Self) -> Ordering {
        self.timestamp.cmp(&other.timestamp)
    }
}

impl PartialEq for Snowflake {
    fn eq(&self, other: &Self) -> bool {
        self.timestamp == other.timestamp
            && self.worker_id == other.worker_id
            && self.sequence == other.sequence
    }
}

/// The SnowflakeGenerator is a thread-safe structure for generating unique Snowflakes.
#[derive(Debug)]
pub struct SnowflakeGenerator {
    worker_id: u8,
    sequence: AtomicU16,
    timestamp: AtomicI64,
}

impl SnowflakeGenerator {
    /// Creates a new SnowflakeGenerator with a given worker ID.
    ///
    /// # Arguments
    ///
    /// * `worker_id` - An 8-bit unsigned integer representing the worker ID.
    pub fn new(worker_id: u8) -> Self {
        SnowflakeGenerator {
            worker_id,
            sequence: AtomicU16::new(0),
            timestamp: AtomicI64::new(0),
        }
    }

    /// Returns the next Snowflake generated by the SnowflakeGenerator.
    pub fn next_snowflake(&self) -> Snowflake {
        loop {
            let current_time = Utc::now().timestamp_millis() - UNIX_START_TIME;
            let last_timestamp = self.timestamp.load(AtomicOrdering::SeqCst);

            if current_time != last_timestamp {
                self.sequence.store(0, AtomicOrdering::SeqCst);
                self.timestamp.store(current_time, AtomicOrdering::SeqCst);
            }

            let sequence = self.sequence.fetch_add(1, AtomicOrdering::SeqCst);

            // If sequence number overflows, wait for the next millisecond
            if sequence < (1 << 12) {
                return Snowflake {
                    timestamp: current_time,
                    worker_id: self.worker_id,
                    sequence,
                };
            } else {
                // Block until the next millisecond arrives
                let sleep_duration = Duration::from_micros(1000);
                thread::sleep(sleep_duration);
            }
        }
    }
}
